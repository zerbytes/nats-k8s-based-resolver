# nats-based-resolver - NATS Account Resolver

NATS based account resolver Kubernetes-native operator.

This operator provides a Kubernetes-native way to manage NATS accounts and users, allowing you to create and manage NATS accounts and users using Kubernetes Custom Resource Definitions (CRDs).

[![Go Report Card](https://goreportcard.com/badge/github.com/zerbytes/nats-based-resolver)](https://goreportcard.com/report/github.com/zerbytes/nats-based-resolver)
[![License](https://img.shields.io/github/license/zerbytes/nats-based-resolver)](LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/zerbytes/nats-based-resolver/test.yml?branch=main)](https://github.com/zerbytes/nats-based-resolver/actions)

## Usage

> **Note**: This project is in early development stages, expect breaking changes and limited features.
> The API is not stable yet.

1. **Deploy the operator** - provides CRDs, generates Operator JWT and `$SYS` account automatically.
2. **Patch / deploy your NATS cluster** - mount and configure the following secrets:
   * `nats-operator-jwt` secret (operator.jwt)
   * `nats-sys-account-jwt` secret (sys.jwt)
   and enable `resolver: FULL` in `nats.conf`.
3. **Deploy the resolver service** (included YAML) - point it at NATS via env `NATS_URL` + mount the `$SYS` resolver creds.
4. **Create an account & user**:

```yaml
apiVersion: zerbytes.net/v1alpha1
kind: NatsAccount
metadata:
  name: payments
spec:
  jetStreamEnabled: true
---
apiVersion: zerbytes.net/v1alpha1
kind: NatsUser
metadata:
  name: payments-api
spec:
  accountRef:
    name: payments
    namespace: default
```

5. Mount `nats-user-payments-api-jwt` secret into your app pod and connect to NATS with the creds.

### Configure NATS To Use The Generated Secrets

To configure your NATS server to use the generated secrets, you need to modify your `nats.conf` file to include the following:

```conf
# nats.conf

# Trust chain
# Operator JWT generated by the operator
operator: /etc/nkeys/operator/operator.jwt   # <== mount Secret here

# The public key of the $SYS account (also in the Secret below)
system_account: ...

# This is the resolver configuration for NATS based account resolver
resolver: {
    type: full
    # Directory in which account jwt will be stored (in Kubernetes this can be a volume mount or emptyDir)
    dir: './jwt'
    # In order to support jwt deletion, set to true.
    # If you set it to true, it is recommend to set `hard_delete: true` as well.
    allow_delete: false
    #hard_delete: true
    # Interval at which a nats-server with a nats based account resolver will compare
    # it's state with one random nats based account resolver in the cluster and if needed,
    # exchange jwt and converge on the same set of jwt.
    interval: "2m"
    # limit on the number of jwt stored, will reject new jwt once limit is hit.
    limit: 1000
    # Timeout for the resolver to wait for a response from the NATS server.
    timeout: "3s"
}
```

(Taken from [NATS docs - Account lookup using Resolver - NATS Based Resolver](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/jwt/resolver#full))

#### Using With NATS Helm Chart

If you are using the [NATS Helm Chart](https://github.com/nats-io/k8s), you can enable the resolver by adding the following to your `values.yaml`:

```yaml
# values.yaml
nats:
  # JWT / Operator / System-account settings
  auth:
    enabled: true


    # Pass the operator- and $SYS-account JWTs (generated by the operator)
    operator:
      jwtSecret:
        name: nats-operator-jwt    # Secret created by the controller
        key:  jwt                  # key inside the Secret
    systemAccount:
      name: ${SYS_ACCOUNT_PK}
      jwtSecret:
        name: nats-sys-account-jwt # Secret with $SYS account JWT
        key:  jwt

    # Tell the server to use FULL resolver mode
    resolver:
      type: full
      dir: /data/jwt
      interval: 2m
      allowDelete: false
      #hardDelete: true # Recommend to set this to true if allowDelete is true
      limit: 10000

    # (Optional) Pre-load the $SYS JWT so the server has it on first boot
    resolverPreload:
      ${SYS_ACCOUNT_PK}:
        secretName: nats-sys-account-jwt
        key: jwt

  # Extra volumes, mounts, and env so the server sees the Secrets
  podTemplate:
    env:
      # expose the public key from the Secret as an env-var
      - name: SYS_ACCOUNT_PK
        valueFrom:
          secretKeyRef:
            name: nats-sys-account-jwt
            key:  pub          # (added below in the controller)

    extraVolumes:
      - name: operator-jwt
        secret:
          secretName: nats-operator-jwt
      - name: sys-account-jwt
        secret:
          secretName: nats-sys-account-jwt

    extraVolumeMounts:
      - name: operator-jwt
        mountPath: /etc/nkeys/operator
        readOnly: true
      - name: sys-account-jwt
        mountPath: /etc/nkeys/accounts
        readOnly: true
```

(Currently these instructions are not fully tested and might be incomplete, please open an issue if you encounter problems.)

## Contributing

Contributions are welcome! A contributing guide will be added soon.

## Development

```bash
# clone repo & init
make generate      # kubebuilder & controller-gen output
make manifests     # CRDs
make docker-build  # build operator & resolver images
make docker-push   # push to your repo
```

## License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.
