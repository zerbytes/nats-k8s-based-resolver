# nats-k8s-based-resolver - NATS Account Resolver

NATS based account resolver Kubernetes-native operator.

This operator provides a Kubernetes-native way to manage NATS accounts and users, allowing you to create and manage NATS accounts and users using Kubernetes Custom Resource Definitions (CRDs).

[![Go Report Card](https://goreportcard.com/badge/github.com/zerbytes/nats-k8s-based-resolver)](https://goreportcard.com/report/github.com/zerbytes/nats-k8s-based-resolver)
[![License](https://img.shields.io/github/license/zerbytes/nats-k8s-based-resolver)](LICENSE)
[![GitHub Workflow Status](https://img.shields.io/github/actions/workflow/status/zerbytes/nats-k8s-based-resolver/test-push.yml?branch=main)](https://github.com/zerbytes/nats-k8s-based-resolver/actions)

## Usage

> **Note**: This project is in early development stages, expect breaking changes and limited features.
> The API is not stable yet.

1. **Deploy the operator** - provides CRDs, generates Operator JWT and `$SYS` account automatically.
2. **Patch / deploy your NATS cluster** - mount and configure the following secrets:
    * `nats-operator-jwt` secret (operator.jwt)
    * `nats-sys-account-jwt` secret (sys.jwt)
    and enable `resolver: FULL` in `nats.conf`.
3. **Deploy the resolver service** (included YAML) - point it at NATS via env `NATS_URL` + mount the `$SYS` resolver creds.
4. **Create an account & user** (these are examples, you can use your own CRDs):
    * `NatsAccount` - defines a NATS account with JetStream enabled and permissions.
    * `NatsUser` - defines a user for the account with specific permissions.

```yaml
apiVersion: natsresolver.zerbytes.net/v1alpha1
kind: NatsAccount
metadata:
  name: payments
spec:
  jetStreamEnabled: true
  limits:
    maxConnections: -1 # -1 means no limit
    maxSubs: -1 # -1 means no limit
    maxData: -1 # -1 means no limit
    maxPayload: 1048576 # 1MB
    maxDiskStorage: -1 # -1 means no limit
    maxMemoryStorage: -1 # -1 means no limit
  permissions:
    # These permissions give full access.
    # You can restrict them to specific subjects if needed.
    publish:
      allow:
        - ">"
    subscribe:
      allow:
        - ">"
        - "_INBOX.>"
    #response:
    #  maxMsgs: 1000 # Optional, max number of response messages
    #  expires: "1h" # Optional, TTL for response messages
    # Optional, if you want to limit the number of messages and their TTL
    responseLimits:
      maxMsgs: 1000
      expires: "1h"
  # Expiration RFC3339 time - optional, infinite if omitted.
  #expiration: "2024-12-31T23:59:59Z"
---
apiVersion: natsresolver.zerbytes.net/v1alpha1
kind: NatsUser
metadata:
  name: payments-api
spec:
  accountRef:
    name: payments
    namespace: default
  # Expiration RFC3339 time - optional, infinite if omitted.
  #expiration: "2024-12-31T23:59:59Z"
  limits:
    maxPayload: 1048576 # 1MB
    maxSubs: -1 # -1 means no limit
    maxData: -1 # -1 means no limit
  permissions:
    # These permissions give full access.
    # You can restrict them to specific subjects if needed.
    publish:
      allow:
        - ">"
    subscribe:
      allow:
        - ">"
        - "_INBOX.>"
```

5. Mount `nats-user-payments-api-jwt` secret into your app pod and connect to NATS with the creds.

### Configure NATS To Use The Generated Secrets

To configure your NATS server to use the generated secrets, you need to modify your `nats.conf` file to include the following:

```conf
# nats.conf

# Make sure JetStream is enabled in your NATS config, if you want to use JetStream.
# Configuring JetStream docs: https://docs.nats.io/running-a-nats-service/configuration/resource_management
jetstream: enabled

# Operator JWT generated by the operator
operator: /etc/nkeys/operator/operator.jwt # <== mount Secret here

# The public key of the $SYS account (also in the Secret below)
system_account: ...

# This is the resolver configuration for NATS based account resolver
resolver: {
    type: full
    # Directory in which account jwt will be stored (in Kubernetes this can be a volume mount or emptyDir)
    dir: './jwt'
    # In order to support jwt deletion, set to true.
    # If you set it to true, it is recommend to set `hard_delete: true` as well.
    allow_delete: false
    #hard_delete: true
    # Interval at which a nats-server with a nats based account resolver will compare
    # it's state with one random nats based account resolver in the cluster and if needed,
    # exchange jwt and converge on the same set of jwt.
    interval: "2m"
    # (optional) limit on the number of jwt stored, will reject new jwt once limit is hit.
    limit: 1000
    # Timeout for the resolver to wait for a response from the NATS server.
    timeout: "3s"
}
```

(Taken from [NATS docs - Account lookup using Resolver - NATS Based Resolver](https://docs.nats.io/running-a-nats-service/configuration/securing_nats/auth_intro/jwt/resolver#full))

#### Using With NATS Helm Chart

If you are using the [NATS Helm Chart](https://github.com/nats-io/k8s), you can enable the resolver by adding the following to your `values.yaml`:

```yaml
# values.yaml
config:
  # [...]
  # JWT / Operator / System-account settings
  auth:
    enabled: true

    # Pass the operator- and $SYS-account JWTs (generated by the operator)
    operator:
      jwtSecret:
        name: nats-operator-jwt    # Secret created by the controller
        key:  jwt                  # key inside the Secret
    systemAccount:
      name: ${SYS_ACCOUNT_PK}
      jwtSecret:
        name: nats-sys-account-jwt # Secret with $SYS account JWT
        key:  jwt

    # Tell the server to use FULL resolver mode
    resolver:
      type: full
      dir: /data/jwt
      interval: 2m
      allowDelete: false
      #hardDelete: true # Recommend to set this to true if allowDelete is true
      limit: 10000 # optional

    # (Optional) Pre-load the $SYS JWT so the server has it on first boot
    resolverPreload:
      ${SYS_ACCOUNT_PK}:
        secretName: nats-sys-account-jwt
        key: jwt

# Extra volumes, mounts, and env so the server sees the Secrets
container:
  env:
    # expose the public key from the Secret as an env-var
    - name: SYS_ACCOUNT_PK
      valueFrom:
        secretKeyRef:
          name: nats-sys-account-jwt
          key:  pub          # (added below in the controller)
  
  patch:
    - op: add
      path: /spec/template/spec/volumes/-
      value:
        name: operator-jwt
        secret:
          secretName: nats-operator-jwt

    - op: add
      path: /spec/template/spec/volumes/-
      value:
        name: sys-account-jwt
        secret:
          secretName: nats-sys-account-jwt

    - op: add
      path: /spec/template/spec/containers/0/volumeMounts/-
      value:
        name: operator-jwt
        mountPath: /etc/nkeys/operator
        readOnly: true

    - op: add
      path: /spec/template/spec/containers/0/volumeMounts/-
      value:
        name: sys-account-jwt
        mountPath: /etc/nkeys/accounts
        readOnly: true

  extraVolumes:
    - name: operator-jwt
      secret:
        secretName: nats-operator-jwt
    - name: sys-account-jwt
      secret:
        secretName: nats-sys-account-jwt

  extraVolumeMounts:
    - name: operator-jwt
      mountPath: /etc/nkeys/operator
      readOnly: true
    - name: sys-account-jwt
      mountPath: /etc/nkeys/accounts
      readOnly: true
```

(Currently these instructions are not fully tested and might be incomplete, please open an issue if you encounter problems.)

## Contributing

Contributions are welcome! A contributing guide will be added soon.

## Development

Golang 1.24.4+ is required to build this project.

```bash
# clone repo & init
make generate      # kubebuilder & controller-gen output
make manifests     # CRDs
make docker-build  # build operator & resolver images
make docker-push   # push to your repo
```

## License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.
